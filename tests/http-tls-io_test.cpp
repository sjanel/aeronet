#include <gtest/gtest.h>

#include <algorithm>
#include <chrono>
#include <cstddef>
#include <string>
#include <utility>

#include "aeronet/compression-config.hpp"
#include "aeronet/encoding.hpp"
#include "aeronet/features.hpp"
#include "aeronet/http-constants.hpp"
#include "aeronet/http-request.hpp"
#include "aeronet/http-response-writer.hpp"
#include "aeronet/http-response.hpp"
#include "aeronet/http-server-config.hpp"
#include "aeronet/http-status-code.hpp"
#include "aeronet/temp-file.hpp"
#include "aeronet/test_server_tls_fixture.hpp"
#include "aeronet/test_tls_client.hpp"
#include "aeronet/test_util.hpp"
#include "file.hpp"

using namespace aeronet;
using namespace std::chrono_literals;

TEST(HttpTlsBasic, LargePayload) {
  std::string largeBody(1 << 24, 'a');
  // Prepare config with in-memory self-signed cert/key
  test::TlsTestServer ts({"http/1.1"}, [&](HttpServerConfig& cfg) {
    cfg.maxOutboundBufferBytes = largeBody.size() + 512;  // +512 for headers
    cfg.keepAliveTimeout = std::chrono::hours(1);
  });
  ts.setDefault([&largeBody]([[maybe_unused]] const HttpRequest& req) {
    return HttpResponse(http::StatusCodeOK, "OK").contentType(http::ContentTypeTextPlain).body(largeBody);
  });
  test::TlsClient client(ts.port());
  auto raw = client.get("/hello", {{"X-Test", "tls"}});
  ASSERT_FALSE(raw.empty());
  EXPECT_TRUE(raw.contains("HTTP/1.1 200"));
  EXPECT_TRUE(raw.contains(largeBody));
}

TEST(HttpTlsCompressionStreaming, CompressionActivatedOverThresholdTls) {
  CompressionConfig compressionConfig;
  compressionConfig.minBytes = 32;
  if constexpr (zlibEnabled()) {
    compressionConfig.preferredFormats.push_back(Encoding::gzip);
  }
  if constexpr (zstdEnabled()) {
    compressionConfig.preferredFormats.push_back(Encoding::zstd);
  }
  if constexpr (brotliEnabled()) {
    compressionConfig.preferredFormats.push_back(Encoding::br);
  }
  // Apply compression configuration while preserving TLS cert/key generated by the
  // TlsTestServer helper (don't overwrite the whole HttpServerConfig instance).
  test::TlsTestServer ts({"http/1.1"}, [&](HttpServerConfig& cfg) { cfg.withCompression(compressionConfig); });

  std::string part1(20000, 'a');
  std::string part2(64000, 'b');

  ts.setDefault([&](const HttpRequest&, HttpResponseWriter& writer) {
    writer.status(http::StatusCodeOK);
    writer.contentType("text/plain");

    static constexpr std::size_t kChunkSize = 512;

    std::string_view buf1 = part1;
    std::string_view buf2 = part2;

    while (!buf1.empty()) {
      std::string_view chunk = buf1.substr(0, std::min(buf1.size(), kChunkSize));
      writer.writeBody(chunk);
      buf1.remove_prefix(chunk.size());
    }

    while (!buf2.empty()) {
      std::string_view chunk = buf2.substr(0, std::min(buf2.size(), kChunkSize));
      writer.writeBody(chunk);
      buf2.remove_prefix(chunk.size());
    }
    writer.end();
  });

  test::TlsClient client(ts.port());
  auto raw = client.get("/sgz", {{"Accept-Encoding", "gzip,zstd,br"}});

  EXPECT_GT(raw.size(), 0);

  // Extract Content-Encoding and de-chunked body using the test helper
  auto encBody = test::extractContentEncodingAndBody(raw);
  std::string enc = std::string(encBody.contentEncoding);
  std::string body = std::move(encBody.body);

  EXPECT_EQ(compressionConfig.preferredFormats.empty(), enc.empty());
  EXPECT_EQ(body, part1 + part2);
}

namespace {
// Large response GET using TlsClient (simplified replacement).
std::string tlsGetLarge(auto port) {
  test::TlsClient client(port);
  if (!client.handshakeOk()) {
    return {};
  }
  return client.get("/large");
}
}  // namespace

TEST(HttpTlsNegative, LargeResponseFragmentation) {
  test::TlsTestServer ts;  // basic TLS
  auto port = ts.port();
  ts.setDefault([](const HttpRequest&) {
    return HttpResponse(200, "OK").contentType(http::ContentTypeTextPlain).body(std::string(300000, 'A'));
  });
  std::string resp = tlsGetLarge(port);
  // helper freed temporary key/cert
  ASSERT_FALSE(resp.empty());
  ASSERT_TRUE(resp.contains("HTTP/1.1 200"));
  ASSERT_TRUE(resp.contains("AAAA"));
}

TEST(HttpOptionsTraceTls, TraceDisabledOnTlsPolicyRejectsTlsTrace) {
  using namespace test;
  // Use TlsTestServer and set TracePolicy to EnabledPlainOnly (reject TRACE over TLS)
  TlsTestServer ts(
      {}, [](HttpServerConfig& cfg) { cfg.withTracePolicy(HttpServerConfig::TraceMethodPolicy::EnabledPlainOnly); });

  // Default handler (not needed but keep server alive)
  ts.setDefault([](const HttpRequest&) { return HttpResponse(http::StatusCodeOK); });

  // Use a TLS client to send a TRACE request; it should be rejected (405)
  TlsClient client(ts.port());
  ASSERT_TRUE(client.handshakeOk());
  client.writeAll("TRACE /test HTTP/1.1\r\nHost: localhost\r\nConnection: close\r\n\r\n");
  auto raw = client.readAll();
  ASSERT_TRUE(raw.contains("405")) << raw;
}

TEST(HttpOptionsTraceTls, TraceEnabledOnTlsAllowsTlsTrace) {
  using namespace test;
  // EnabledPlainAndTLS should allow TRACE over TLS
  TlsTestServer ts(
      {}, [](HttpServerConfig& cfg) { cfg.withTracePolicy(HttpServerConfig::TraceMethodPolicy::EnabledPlainAndTLS); });
  ts.setDefault([](const HttpRequest&) { return HttpResponse(http::StatusCodeOK); });

  TlsClient client(ts.port());
  ASSERT_TRUE(client.handshakeOk());
  client.writeAll("TRACE /test HTTP/1.1\r\nHost: localhost\r\nConnection: close\r\n\r\n");
  auto raw = client.readAll();
  ASSERT_TRUE(raw.contains("200")) << raw;
}

TEST(HttpTlsStreaming, ChunkedSimpleTls) {
  test::TlsTestServer ts({"http/1.1"});
  ts.setDefault([]([[maybe_unused]] const HttpRequest& req, HttpResponseWriter& writer) {
    writer.status(200);
    writer.contentType("text/plain");
    writer.writeBody("hello ");
    writer.writeBody("tls");
    writer.end();
  });
  test::TlsClient client(ts.port());
  auto raw = client.get("/stream", {});
  ASSERT_FALSE(raw.empty());
  ASSERT_TRUE(raw.contains("HTTP/1.1 200"));
  ASSERT_TRUE(raw.contains("6\r\nhello "));  // chunk size 6
  ASSERT_TRUE(raw.contains("3\r\ntls"));     // chunk size 3
}

TEST(HttpTlsStreaming, SendFileFallbackBuffers) {
  constexpr std::string_view kPayload = "tls sendfile body contents";
  test::ScopedTempDir tmpDir;
  test::ScopedTempFile tmp(tmpDir, kPayload);
  std::string path = tmp.filePath().string();

  test::TlsTestServer ts({"http/1.1"});
  ts.setDefault([path](const HttpRequest&, HttpResponseWriter& writer) {
    writer.status(http::StatusCodeOK);
    writer.contentType("application/octet-stream");
    writer.file(File(path));
    writer.end();
  });

  test::TlsClient client(ts.port());
  auto raw = client.get("/file", {});

  ASSERT_FALSE(raw.empty());
  ASSERT_TRUE(raw.contains("HTTP/1.1 200"));
  ASSERT_TRUE(raw.contains("Content-Length: " + std::to_string(kPayload.size())));
  ASSERT_FALSE(raw.contains("Transfer-Encoding: chunked"));

  auto headerEnd = raw.find(http::DoubleCRLF);
  ASSERT_NE(std::string::npos, headerEnd);
  std::string body = raw.substr(headerEnd + http::DoubleCRLF.size());
  EXPECT_EQ(body, kPayload);
}

TEST(HttpTlsStreamingBackpressure, LargeChunksTls) {
  test::TlsTestServer ts({"http/1.1"}, nullptr, std::chrono::milliseconds{20});
  // Create large chunks to exercise TLS partial writes
  static constexpr std::size_t kChunkSize = 65536;
  static constexpr int kNbChunks = 32;

  std::string chunk(kChunkSize, 'X');
  ts.setDefault([&]([[maybe_unused]] const HttpRequest& req, HttpResponseWriter& writer) {
    writer.status(200);
    writer.contentType("text/plain");
    // write several large chunks
    for (int chunkPos = 0; chunkPos < kNbChunks; ++chunkPos) {
      writer.writeBody(chunk);
    }
    writer.end();
  });

  test::TlsClient client(ts.port());
  auto raw = client.get("/large", {});
  ASSERT_FALSE(raw.empty());
  // Response should contain a sizable body; simple sanity: expect more than one chunk size marker or body length
  EXPECT_GT(raw.size(), kChunkSize * static_cast<std::size_t>(kNbChunks));
}
