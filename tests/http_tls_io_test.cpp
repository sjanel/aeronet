#include <gtest/gtest.h>

#include <algorithm>
#include <chrono>
#include <cstddef>
#include <string>
#include <utility>

#include "aeronet/compression-config.hpp"
#include "aeronet/encoding.hpp"
#include "aeronet/http-constants.hpp"
#include "aeronet/http-request.hpp"
#include "aeronet/http-response-writer.hpp"
#include "aeronet/http-response.hpp"
#include "aeronet/http-server-config.hpp"
#include "aeronet/test_server_tls_fixture.hpp"
#include "aeronet/test_tls_client.hpp"
#include "aeronet/test_util.hpp"

using namespace aeronet;
using namespace std::chrono_literals;

TEST(HttpTlsBasic, LargePayload) {
  std::string largeBody(1 << 24, 'a');
  // Prepare config with in-memory self-signed cert/key
  aeronet::test::TlsTestServer ts({"http/1.1"}, [&](aeronet::HttpServerConfig& cfg) {
    cfg.maxOutboundBufferBytes = largeBody.size() + 512;  // +512 for headers
    cfg.keepAliveTimeout = std::chrono::hours(1);
  });
  ts.setDefault([&largeBody]([[maybe_unused]] const aeronet::HttpRequest& req) {
    return aeronet::HttpResponse(200, "OK").contentType(aeronet::http::ContentTypeTextPlain).body(largeBody);
  });
  aeronet::test::TlsClient client(ts.port());
  auto raw = client.get("/hello", {{"X-Test", "tls"}});
  ASSERT_FALSE(raw.empty());
  EXPECT_TRUE(raw.contains("HTTP/1.1 200"));
  EXPECT_TRUE(raw.contains(largeBody));
}

TEST(HttpTlsCompressionStreaming, CompressionActivatedOverThresholdTls) {
  CompressionConfig compressionConfig;
  compressionConfig.minBytes = 32;
#ifdef AERONET_ENABLE_ZLIB
  compressionConfig.preferredFormats.push_back(Encoding::gzip);
#endif
#ifdef AERONET_ENABLE_ZSTD
  compressionConfig.preferredFormats.push_back(Encoding::zstd);
#endif
#ifdef AERONET_ENABLE_BROTLI
  compressionConfig.preferredFormats.push_back(Encoding::br);
#endif
  // Apply compression configuration while preserving TLS cert/key generated by the
  // TlsTestServer helper (don't overwrite the whole HttpServerConfig instance).
  aeronet::test::TlsTestServer ts({"http/1.1"}, [&](HttpServerConfig& cfg) { cfg.withCompression(compressionConfig); });

  std::string part1(20000, 'a');
  std::string part2(64000, 'b');

  ts.setDefault([&](const HttpRequest&, HttpResponseWriter& writer) {
    writer.statusCode(200);
    writer.contentType("text/plain");

    static constexpr std::size_t kChunkSize = 512;

    std::string_view buf1 = part1;
    std::string_view buf2 = part2;

    while (!buf1.empty()) {
      std::string_view chunk = buf1.substr(0, std::min(buf1.size(), kChunkSize));
      writer.writeBody(chunk);
      buf1.remove_prefix(chunk.size());
    }

    while (!buf2.empty()) {
      std::string_view chunk = buf2.substr(0, std::min(buf2.size(), kChunkSize));
      writer.writeBody(chunk);
      buf2.remove_prefix(chunk.size());
    }
    writer.end();
  });

  aeronet::test::TlsClient client(ts.port());
  auto raw = client.get("/sgz", {{"Accept-Encoding", "gzip,zstd,br"}});
  ASSERT_FALSE(raw.empty());

  EXPECT_GT(raw.size(), 0);

  // Extract Content-Encoding and de-chunked body using the test helper
  auto encBody = aeronet::test::extractContentEncodingAndBody(raw);
  std::string enc = std::string(encBody.contentEncoding);
  std::string body = std::move(encBody.body);

  EXPECT_EQ(compressionConfig.preferredFormats.empty(), enc.empty());
  EXPECT_EQ(body, part1 + part2);
}

namespace {
// Large response GET using TlsClient (simplified replacement).
std::string tlsGetLarge(auto port) {
  aeronet::test::TlsClient client(port);
  if (!client.handshakeOk()) {
    return {};
  }
  return client.get("/large");
}
}  // namespace

TEST(HttpTlsNegative, LargeResponseFragmentation) {
  aeronet::test::TlsTestServer ts;  // basic TLS
  auto port = ts.port();
  ts.setDefault([](const aeronet::HttpRequest&) {
    return aeronet::HttpResponse(200, "OK")
        .contentType(aeronet::http::ContentTypeTextPlain)
        .body(std::string(300000, 'A'));
  });
  std::string resp = tlsGetLarge(port);
  // helper freed temporary key/cert
  ASSERT_FALSE(resp.empty());
  ASSERT_TRUE(resp.contains("HTTP/1.1 200"));
  ASSERT_TRUE(resp.contains("AAAA"));
}

TEST(HttpOptionsTraceTls, TraceDisabledOnTlsPolicyRejectsTlsTrace) {
  using namespace aeronet::test;
  // Use TlsTestServer and set TracePolicy to EnabledPlainOnly (reject TRACE over TLS)
  TlsTestServer ts(
      {}, [](HttpServerConfig& cfg) { cfg.withTracePolicy(HttpServerConfig::TraceMethodPolicy::EnabledPlainOnly); });

  // Default handler (not needed but keep server alive)
  ts.setDefault([](const aeronet::HttpRequest&) { return aeronet::HttpResponse(200); });

  // Use a TLS client to send a TRACE request; it should be rejected (405)
  TlsClient client(ts.port());
  ASSERT_TRUE(client.handshakeOk());
  client.writeAll("TRACE /test HTTP/1.1\r\nHost: localhost\r\nConnection: close\r\n\r\n");
  auto raw = client.readAll();
  ASSERT_TRUE(raw.contains("405")) << raw;
}

TEST(HttpOptionsTraceTls, TraceEnabledOnTlsAllowsTlsTrace) {
  using namespace aeronet::test;
  // EnabledPlainAndTLS should allow TRACE over TLS
  TlsTestServer ts(
      {}, [](HttpServerConfig& cfg) { cfg.withTracePolicy(HttpServerConfig::TraceMethodPolicy::EnabledPlainAndTLS); });
  ts.setDefault([](const aeronet::HttpRequest&) { return aeronet::HttpResponse(200); });

  TlsClient client(ts.port());
  ASSERT_TRUE(client.handshakeOk());
  client.writeAll("TRACE /test HTTP/1.1\r\nHost: localhost\r\nConnection: close\r\n\r\n");
  auto raw = client.readAll();
  ASSERT_TRUE(raw.contains("200")) << raw;
}

TEST(HttpTlsStreaming, ChunkedSimpleTls) {
  aeronet::test::TlsTestServer ts({"http/1.1"});
  ts.setDefault([]([[maybe_unused]] const aeronet::HttpRequest& req, aeronet::HttpResponseWriter& writer) {
    writer.statusCode(200);
    writer.contentType("text/plain");
    writer.writeBody("hello ");
    writer.writeBody("tls");
    writer.end();
  });
  aeronet::test::TlsClient client(ts.port());
  auto raw = client.get("/stream", {});
  ASSERT_FALSE(raw.empty());
  ASSERT_TRUE(raw.contains("HTTP/1.1 200"));
  ASSERT_TRUE(raw.contains("6\r\nhello "));  // chunk size 6
  ASSERT_TRUE(raw.contains("3\r\ntls"));     // chunk size 3
}

TEST(HttpTlsStreamingBackpressure, LargeChunksTls) {
  aeronet::test::TlsTestServer ts({"http/1.1"}, nullptr, std::chrono::milliseconds{20});
  // Create large chunks to exercise TLS partial writes
  static constexpr std::size_t kChunkSize = 65536;
  static constexpr int kNbChunks = 32;

  std::string chunk(kChunkSize, 'X');
  ts.setDefault([&]([[maybe_unused]] const aeronet::HttpRequest& req, aeronet::HttpResponseWriter& writer) {
    writer.statusCode(200);
    writer.contentType("text/plain");
    // write several large chunks
    for (int chunkPos = 0; chunkPos < kNbChunks; ++chunkPos) {
      writer.writeBody(chunk);
    }
    writer.end();
  });

  aeronet::test::TlsClient client(ts.port());
  auto raw = client.get("/large", {});
  ASSERT_FALSE(raw.empty());
  // Response should contain a sizable body; simple sanity: expect more than one chunk size marker or body length
  EXPECT_GT(raw.size(), kChunkSize * static_cast<std::size_t>(kNbChunks));
}
