function(AeronetSetProjectProperties name)

  # Export the version string to consumers. Use a PUBLIC compile definition so
  # installed/exported targets provide AERONET_VERSION_STR to downstream
  # consumers (vcpkg/Conan consumers link the target but will not see PRIVATE
  # compile definitions). Define it as a C string literal.
  target_compile_definitions(${name} PUBLIC "AERONET_VERSION_STR=\"${AERONET_PROJECT_VERSION}\"")

  # Warning levels
  if(AERONET_ENABLE_WARNINGS)
    if(CMAKE_BUILD_TYPE STREQUAL "Debug")
      # Basic warnings
      if (CMAKE_CXX_COMPILER_ID MATCHES "Clang|GNU")
        target_compile_options(${name} PRIVATE -Wall -Wextra -Wpedantic -Wconversion -Wsign-conversion)
        if (AERONET_WARNINGS_AS_ERRORS)
            target_compile_options(${name} PRIVATE -Werror)
        endif()
      endif()
    else()
      if (CMAKE_CXX_COMPILER_ID MATCHES "Clang|GNU")
        target_compile_options(${name} PRIVATE -Wall -Wdisabled-optimization)
      endif()
    endif()
  endif()

  # Use lld linker with Clang if available for faster linking
  if(CMAKE_CXX_COMPILER_ID MATCHES "Clang")
    # Try to find lld (unversioned first, then versioned matching compiler version)
    find_program(LLD_PROGRAM lld)
    
    if(NOT LLD_PROGRAM)
      # Extract version from compiler if it has one (e.g., clang-21 -> -21)
      string(REGEX MATCH "-[0-9]+$" COMPILER_VERSION_SUFFIX "${CMAKE_CXX_COMPILER}")
      if(COMPILER_VERSION_SUFFIX)
        find_program(LLD_PROGRAM "lld${COMPILER_VERSION_SUFFIX}")
      endif()
    endif()
    
    if(LLD_PROGRAM)
      target_link_options(${name} PRIVATE "-fuse-ld=lld")
    endif()
  endif()

  # Address/UB sanitizers (activated via AERONET_ENABLE_ASAN)
  if(AERONET_ENABLE_ASAN)
    target_compile_options(${name} PRIVATE ${AERONET_ASAN_OPTIONS})
    target_link_options(${name} PRIVATE ${AERONET_ASAN_OPTIONS})
  endif()

  if(AERONET_ENABLE_CLANG_TIDY AND CLANG_TIDY)
    set_target_properties(${name} PROPERTIES
      CXX_CLANG_TIDY "clang-tidy;--extra-arg-before=--driver-mode=g++"
    )
  endif()
  if (LINK_AMC)
    target_link_libraries(${name} PRIVATE amc::amc)
  endif()
  if(AERONET_ENABLE_SPDLOG)
    # Use header-only mode to avoid introducing a link dependency that would
    # force exporting/packaging spdlog. Consumers can supply their own spdlog
    # if they also define AERONET_ENABLE_SPDLOG, otherwise they build without it.
    target_compile_definitions(${name} PUBLIC AERONET_ENABLE_SPDLOG)
    if(AERONET_SPDLOG_USE_STD_FORMAT)
      target_compile_definitions(${name} PUBLIC SPDLOG_USE_STD_FORMAT)
    endif()
    # Do NOT link the spdlog target (even privately) or the install(EXPORT ...) step
    # will complain that the exported aeronet targets require a target not in any
    # export set. Instead, harvest its include directories (header-only) so builds succeed.
    if(TARGET spdlog::spdlog)
      get_target_property(_spdlog_includes spdlog::spdlog INTERFACE_INCLUDE_DIRECTORIES)
      if(_spdlog_includes)
        target_include_directories(${name} PRIVATE ${_spdlog_includes})
      endif()
    elseif(TARGET spdlog)
      get_target_property(_spdlog_includes spdlog INTERFACE_INCLUDE_DIRECTORIES)
      if(_spdlog_includes)
        target_include_directories(${name} PRIVATE ${_spdlog_includes})
      endif()
    endif()
  endif()
  if(AERONET_ENABLE_OPENSSL)
    # Expose compile definition so core can gate TLS logic, but do not link OpenSSL here.
    # Only the dedicated aeronet_tls module should link against OpenSSL to contain dependency surface.
    target_compile_definitions(${name} PUBLIC AERONET_ENABLE_OPENSSL)
  endif()
  if(AERONET_ENABLE_HTTP2)
    target_compile_definitions(${name} PUBLIC AERONET_ENABLE_HTTP2)
  endif()
  if(AERONET_ENABLE_ZLIB)
    target_compile_definitions(${name} PUBLIC AERONET_ENABLE_ZLIB)
    if (AERONET_ENABLE_ZLIBNG)
      target_compile_definitions(${name} PUBLIC AERONET_ENABLE_ZLIBNG)
    endif()
  endif()
  if(AERONET_ENABLE_ZSTD)
    target_compile_definitions(${name} PUBLIC AERONET_ENABLE_ZSTD)
  endif()
  if(AERONET_ENABLE_BROTLI)
    target_compile_definitions(${name} PUBLIC AERONET_ENABLE_BROTLI)
    # Harvest include directories from one of the brotli targets if available (applies to ALL targets needing headers).
    set(_brotli_includes "")
    foreach(_btl_target IN ITEMS brotlicommon brotlienc brotlidec)
      if(TARGET ${_btl_target})
        get_target_property(_tmp_includes ${_btl_target} INTERFACE_INCLUDE_DIRECTORIES)
        if(_tmp_includes)
          set(_brotli_includes ${_tmp_includes})
          break()
        endif()
      endif()
    endforeach()
    if(_brotli_includes)
      # Create an INTERFACE wrapper for brotli include dirs so we can re-export
      # them cleanly to Aeronet consumers without exposing the library link.
      if(NOT TARGET aeronet_brotli_headers)
        add_library(aeronet_brotli_headers INTERFACE)
      endif()
      if(NOT TARGET aeronet::brotli_headers)
        add_library(aeronet::brotli_headers ALIAS aeronet_brotli_headers)
      endif()
      target_include_directories(aeronet_brotli_headers INTERFACE ${_brotli_includes})
      target_link_libraries(${name} PUBLIC aeronet::brotli_headers)
    endif()
    # Fallback: some brotli builds expose no INTERFACE include dirs (e.g. legacy or minimal builds); use FetchContent source dir.
    if(NOT _brotli_includes AND DEFINED brotli_SOURCE_DIR)
      if(EXISTS "${brotli_SOURCE_DIR}/c/include")
        if(NOT TARGET aeronet_brotli_headers)
          add_library(aeronet_brotli_headers INTERFACE)
        endif()
        if(NOT TARGET aeronet::brotli_headers)
          add_library(aeronet::brotli_headers ALIAS aeronet_brotli_headers)
        endif()
        target_include_directories(aeronet_brotli_headers INTERFACE "${brotli_SOURCE_DIR}/c/include")
        target_link_libraries(${name} PUBLIC aeronet::brotli_headers)
      endif()
    endif()
    # Only link brotli libs into objects library to reduce export surface; others see headers only.
    if(${name} STREQUAL "aeronet_objects")
      if(TARGET brotlicommon AND TARGET brotlidec AND TARGET brotlienc)
        target_link_libraries(${name} PRIVATE brotlicommon brotlidec brotlienc)
      endif()
    endif()
  endif()
  if(AERONET_ENABLE_OPENTELEMETRY)
    target_compile_definitions(${name} PUBLIC AERONET_ENABLE_OPENTELEMETRY)
  endif()
  if(AERONET_ENABLE_WEBSOCKET)
    target_compile_definitions(${name} PUBLIC AERONET_ENABLE_WEBSOCKET)
  endif()
  if(AERONET_ENABLE_ASYNC_HANDLERS)
    target_compile_definitions(${name} PUBLIC AERONET_ENABLE_ASYNC_HANDLERS)
  endif()
  if (CMAKE_GENERATOR MATCHES "Ninja")
    set_property(TARGET ${name} PROPERTY JOB_POOL_COMPILE compile_pool)
    set_property(TARGET ${name} PROPERTY JOB_POOL_LINK link_pool)
  endif()
  if (AERONET_ENABLE_ADDITIONAL_MEMORY_CHECKS)
    target_compile_definitions(${name} PUBLIC AERONET_ENABLE_ADDITIONAL_MEMORY_CHECKS)
  endif()
endfunction()

function(AeronetAddProjectExecutable name)
  add_executable(${name} ${ARGN})
  AeronetSetProjectProperties(${name})
endfunction()

function(AeronetAddProjectLibrary name)
  if(AERONET_BUILD_SHARED)
    add_library(${name} SHARED ${ARGN})
  else()
    add_library(${name} STATIC ${ARGN})
  endif()
  AeronetSetProjectProperties(${name})
endfunction()