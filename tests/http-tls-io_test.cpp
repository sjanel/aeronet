#include <gtest/gtest.h>
#include <openssl/evp.h>
#include <openssl/types.h>

#include <algorithm>
#include <cerrno>
#include <chrono>
#include <cstddef>
#include <cstring>
#include <memory>
#include <span>
#include <string>
#include <thread>
#include <utility>

#include "aeronet/compression-config.hpp"
#include "aeronet/encoding.hpp"
#include "aeronet/features.hpp"
#include "aeronet/file.hpp"
#include "aeronet/http-constants.hpp"
#include "aeronet/http-request.hpp"
#include "aeronet/http-response-writer.hpp"
#include "aeronet/http-response.hpp"
#include "aeronet/http-server-config.hpp"
#include "aeronet/http-status-code.hpp"
#include "aeronet/server-stats.hpp"
#include "aeronet/temp-file.hpp"
#include "aeronet/test_server_tls_fixture.hpp"
#include "aeronet/test_tls_client.hpp"
#include "aeronet/test_util.hpp"
#include "aeronet/tls-config.hpp"
#include "aeronet/tls-ticket-key-store.hpp"

using namespace aeronet;
using namespace std::chrono_literals;

TEST(HttpTlsBasic, LargePayload) {
  std::string largeBody(1 << 24, 'a');
  // Prepare config with in-memory self-signed cert/key
  test::TlsTestServer ts({"http/1.1"}, [&](HttpServerConfig& cfg) {
    cfg.withMaxOutboundBufferBytes(largeBody.size() + 512);  // +512 for headers
    cfg.withKeepAliveTimeout(std::chrono::hours(1));
  });
  ts.setDefault([&largeBody]([[maybe_unused]] const HttpRequest& req) {
    return HttpResponse(http::StatusCodeOK, "OK").body(largeBody);
  });
  test::TlsClient client(ts.port());
  auto raw = client.get("/hello", {{"X-Test", "tls"}});
  ASSERT_FALSE(raw.empty());
  EXPECT_TRUE(raw.contains("HTTP/1.1 200"));
  EXPECT_TRUE(raw.contains(largeBody));
}

TEST(HttpTlsCompressionStreaming, CompressionActivatedOverThresholdTls) {
  CompressionConfig compressionConfig;
  compressionConfig.minBytes = 32;
  if constexpr (zlibEnabled()) {
    compressionConfig.preferredFormats.push_back(Encoding::gzip);
  }
  if constexpr (zstdEnabled()) {
    compressionConfig.preferredFormats.push_back(Encoding::zstd);
  }
  if constexpr (brotliEnabled()) {
    compressionConfig.preferredFormats.push_back(Encoding::br);
  }
  // Apply compression configuration while preserving TLS cert/key generated by the
  // TlsTestServer helper (don't overwrite the whole HttpServerConfig instance).
  test::TlsTestServer ts({"http/1.1"}, [&](HttpServerConfig& cfg) { cfg.withCompression(compressionConfig); });

  std::string part1(20000, 'a');
  std::string part2(64000, 'b');

  ts.setDefault([&](const HttpRequest&, HttpResponseWriter& writer) {
    writer.status(http::StatusCodeOK);
    writer.contentType("text/plain");

    static constexpr std::size_t kChunkSize = 512;

    std::string_view buf1 = part1;
    std::string_view buf2 = part2;

    while (!buf1.empty()) {
      std::string_view chunk = buf1.substr(0, std::min(buf1.size(), kChunkSize));
      writer.writeBody(chunk);
      buf1.remove_prefix(chunk.size());
    }

    while (!buf2.empty()) {
      std::string_view chunk = buf2.substr(0, std::min(buf2.size(), kChunkSize));
      writer.writeBody(chunk);
      buf2.remove_prefix(chunk.size());
    }
    writer.end();
  });

  test::TlsClient client(ts.port());
  auto raw = client.get("/sgz", {{"Accept-Encoding", "gzip,zstd,br"}});

  EXPECT_GT(raw.size(), 0);

  // Extract Content-Encoding and de-chunked body using the test helper
  auto encBody = test::extractContentEncodingAndBody(raw);
  std::string enc = std::string(encBody.contentEncoding);
  std::string body = std::move(encBody.body);

  EXPECT_EQ(compressionConfig.preferredFormats.empty(), enc.empty());
  EXPECT_EQ(body, part1 + part2);
}

namespace {
// Large response GET using TlsClient (simplified replacement).
std::string tlsGetLarge(auto port) {
  test::TlsClient client(port);
  if (!client.handshakeOk()) {
    return {};
  }
  return client.get("/large");
}
}  // namespace

TEST(HttpTlsNegative, LargeResponseFragmentation) {
  test::TlsTestServer ts;  // basic TLS
  auto port = ts.port();
  ts.setDefault([](const HttpRequest&) { return HttpResponse(200, "OK").body(std::string(300000, 'A')); });
  std::string resp = tlsGetLarge(port);
  // helper freed temporary key/cert
  ASSERT_FALSE(resp.empty());
  ASSERT_TRUE(resp.contains("HTTP/1.1 200"));
  ASSERT_TRUE(resp.contains("AAAA"));
}

TEST(HttpOptionsTraceTls, TraceDisabledOnTlsPolicyRejectsTlsTrace) {
  using namespace test;
  // Use TlsTestServer and set TracePolicy to EnabledPlainOnly (reject TRACE over TLS)
  TlsTestServer ts(
      {}, [](HttpServerConfig& cfg) { cfg.withTracePolicy(HttpServerConfig::TraceMethodPolicy::EnabledPlainOnly); });

  // Default handler (not needed but keep server alive)
  ts.setDefault([](const HttpRequest&) { return HttpResponse(http::StatusCodeOK); });

  // Use a TLS client to send a TRACE request; it should be rejected (405)
  TlsClient client(ts.port());
  ASSERT_TRUE(client.handshakeOk());
  client.writeAll("TRACE /test HTTP/1.1\r\nHost: localhost\r\nConnection: close\r\n\r\n");
  auto raw = client.readAll();
  ASSERT_TRUE(raw.contains("405")) << raw;
}

TEST(HttpOptionsTraceTls, TraceEnabledOnTlsAllowsTlsTrace) {
  using namespace test;
  // EnabledPlainAndTLS should allow TRACE over TLS
  TlsTestServer ts(
      {}, [](HttpServerConfig& cfg) { cfg.withTracePolicy(HttpServerConfig::TraceMethodPolicy::EnabledPlainAndTLS); });
  ts.setDefault([](const HttpRequest&) { return HttpResponse(http::StatusCodeOK); });

  TlsClient client(ts.port());
  ASSERT_TRUE(client.handshakeOk());
  client.writeAll("TRACE /test HTTP/1.1\r\nHost: localhost\r\nConnection: close\r\n\r\n");
  auto raw = client.readAll();
  ASSERT_TRUE(raw.contains("200")) << raw;
}

TEST(HttpTlsStreaming, ChunkedSimpleTls) {
  test::TlsTestServer ts({"http/1.1"});
  ts.setDefault([]([[maybe_unused]] const HttpRequest& req, HttpResponseWriter& writer) {
    writer.status(200);
    writer.contentType("text/plain");
    writer.writeBody("hello ");
    writer.writeBody("tls");
    writer.end();
  });
  test::TlsClient client(ts.port());
  auto raw = client.get("/stream", {});
  ASSERT_FALSE(raw.empty());
  ASSERT_TRUE(raw.contains("HTTP/1.1 200"));
  ASSERT_TRUE(raw.contains("6\r\nhello "));  // chunk size 6
  ASSERT_TRUE(raw.contains("3\r\ntls"));     // chunk size 3
}

TEST(HttpTlsStreaming, SendFileFallbackBuffers) {
  constexpr std::string_view kPayload = "tls sendfile body contents";
  test::ScopedTempDir tmpDir;
  test::ScopedTempFile tmp(tmpDir, kPayload);
  std::string path = tmp.filePath().string();

  test::TlsTestServer ts({"http/1.1"});
  ts.setDefault([path](const HttpRequest&, HttpResponseWriter& writer) {
    writer.status(http::StatusCodeOK);
    writer.file(File(path));
    writer.end();
  });

  test::TlsClient client(ts.port());
  auto raw = client.get("/file", {});

  ASSERT_FALSE(raw.empty());
  ASSERT_TRUE(raw.contains("HTTP/1.1 200"));
  ASSERT_TRUE(raw.contains("Content-Length: " + std::to_string(kPayload.size())));
  ASSERT_FALSE(raw.contains("Transfer-Encoding: chunked"));

  auto headerEnd = raw.find(http::DoubleCRLF);
  ASSERT_NE(std::string::npos, headerEnd);
  std::string body = raw.substr(headerEnd + http::DoubleCRLF.size());
  EXPECT_EQ(body, kPayload);
}

TEST(HttpTlsStreamingBackpressure, LargeChunksTls) {
  test::TlsTestServer ts({"http/1.1"}, nullptr, std::chrono::milliseconds{20});
  // Create large chunks to exercise TLS partial writes
  static constexpr std::size_t kChunkSize = 65536;
  static constexpr int kNbChunks = 32;

  std::string chunk(kChunkSize, 'X');
  ts.setDefault([&]([[maybe_unused]] const HttpRequest& req, HttpResponseWriter& writer) {
    writer.status(200);
    writer.contentType("text/plain");
    // write several large chunks
    for (int chunkPos = 0; chunkPos < kNbChunks; ++chunkPos) {
      writer.writeBody(chunk);
    }
    writer.end();
  });

  test::TlsClient client(ts.port());
  auto raw = client.get("/large", {});
  ASSERT_FALSE(raw.empty());
  // Response should contain a sizable body; simple sanity: expect more than one chunk size marker or body length
  EXPECT_GT(raw.size(), kChunkSize * static_cast<std::size_t>(kNbChunks));
}

namespace {
struct EvpMacCtxDeleter {
  void operator()(EVP_MAC_CTX* ctx) const {
    if (ctx != nullptr) {
      ::EVP_MAC_CTX_free(ctx);
    }
  }
};
using EvpMacCtxPtr = std::unique_ptr<EVP_MAC_CTX, EvpMacCtxDeleter>;

EvpMacCtxPtr createMacContext() {
  EVP_MAC* mac = ::EVP_MAC_fetch(nullptr, "HMAC", nullptr);
  if (mac == nullptr) {
    return nullptr;
  }
  EVP_MAC_CTX* ctx = ::EVP_MAC_CTX_new(mac);
  ::EVP_MAC_free(mac);
  return EvpMacCtxPtr(ctx);
}
}  // namespace

TEST(HttpTlsSessionTickets, StaticKeyStoreEncryptsAndDecrypts) {
  TlsTicketKeyStore store(std::chrono::seconds(3600), 4);
  TLSConfig::SessionTicketKey material{};
  for (std::size_t i = 0; i < material.size(); ++i) {
    material[i] = static_cast<std::byte>(i);
  }
  store.loadStaticKeys(std::span<const TLSConfig::SessionTicketKey>{&material, 1});

  unsigned char name[16]{};
  unsigned char iv[EVP_MAX_IV_LENGTH]{};
  std::unique_ptr<EVP_CIPHER_CTX, decltype(&::EVP_CIPHER_CTX_free)> encCtx{::EVP_CIPHER_CTX_new(),
                                                                           &::EVP_CIPHER_CTX_free};
  EvpMacCtxPtr encMac = createMacContext();
  ASSERT_NE(encCtx.get(), nullptr);
  ASSERT_NE(encMac.get(), nullptr);
  ASSERT_EQ(store.processTicket(name, iv, EVP_MAX_IV_LENGTH, encCtx.get(), encMac.get(), 1), 1);

  std::unique_ptr<EVP_CIPHER_CTX, decltype(&::EVP_CIPHER_CTX_free)> decCtx{::EVP_CIPHER_CTX_new(),
                                                                           &::EVP_CIPHER_CTX_free};
  EvpMacCtxPtr decMac = createMacContext();
  ASSERT_NE(decCtx.get(), nullptr);
  ASSERT_NE(decMac.get(), nullptr);
  ASSERT_EQ(store.processTicket(name, iv, EVP_MAX_IV_LENGTH, decCtx.get(), decMac.get(), 0), 1);
}

TEST(HttpTlsSessionTickets, AutoRotationRefreshesPrimaryKeyAndRejectsUnknown) {
  TlsTicketKeyStore store(std::chrono::seconds(1), 2);

  auto issue = [&](unsigned char (&out)[16]) {
    unsigned char iv[EVP_MAX_IV_LENGTH]{};
    std::unique_ptr<EVP_CIPHER_CTX, decltype(&::EVP_CIPHER_CTX_free)> ctx{::EVP_CIPHER_CTX_new(),
                                                                          &::EVP_CIPHER_CTX_free};
    EvpMacCtxPtr mctx = createMacContext();
    ASSERT_NE(ctx.get(), nullptr);
    ASSERT_NE(mctx.get(), nullptr);
    ASSERT_EQ(store.processTicket(out, iv, EVP_MAX_IV_LENGTH, ctx.get(), mctx.get(), 1), 1);
  };

  unsigned char first[16]{};
  issue(first);
  std::this_thread::sleep_for(std::chrono::seconds(1));
  unsigned char second[16]{};
  issue(second);
  EXPECT_NE(std::memcmp(first, second, sizeof(first)), 0);

  unsigned char bogus[16]{};
  unsigned char iv[EVP_MAX_IV_LENGTH]{};
  std::unique_ptr<EVP_CIPHER_CTX, decltype(&::EVP_CIPHER_CTX_free)> ctx{::EVP_CIPHER_CTX_new(), &::EVP_CIPHER_CTX_free};
  EvpMacCtxPtr mctx = createMacContext();
  ASSERT_NE(ctx.get(), nullptr);
  ASSERT_NE(mctx.get(), nullptr);
  EXPECT_EQ(store.processTicket(bogus, iv, EVP_MAX_IV_LENGTH, ctx.get(), mctx.get(), 0), 0);
}

#ifdef AERONET_ENABLE_KTLS
TEST(HttpTlsKtlsMode, EnabledModeTracksStats) {
  test::TlsTestServer ts({"http/1.1"},
                         [](HttpServerConfig& cfg) { cfg.withTlsKtlsMode(TLSConfig::KtlsMode::Enabled); });
  ts.setDefault([](const HttpRequest&) { return HttpResponse("ktls"); });

  test::TlsClient client(ts.port());
  ASSERT_TRUE(client.handshakeOk());
  auto raw = client.get("/ktls", {});
  ASSERT_FALSE(raw.empty());
  ASSERT_TRUE(raw.contains("HTTP/1.1 200"));

  const auto stats = ts.stats();
  ASSERT_GE(stats.totalRequestsServed, 1U);
  EXPECT_GE(stats.ktlsSendEnabledConnections + stats.ktlsSendEnableFallbacks, 1U);
  EXPECT_EQ(stats.ktlsSendForcedShutdowns, 0U);
}

#endif
