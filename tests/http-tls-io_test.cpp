#include <gtest/gtest.h>
#include <openssl/bio.h>
#include <openssl/evp.h>
#include <openssl/types.h>

#include <algorithm>
#include <cerrno>
#include <chrono>
#include <cstddef>
#include <cstring>
#include <memory>
#include <ranges>
#include <span>
#include <string>
#include <thread>
#include <utility>

#include "aeronet/compression-config.hpp"
#include "aeronet/encoding.hpp"
#include "aeronet/features.hpp"
#include "aeronet/file.hpp"
#include "aeronet/http-constants.hpp"
#include "aeronet/http-helpers.hpp"
#include "aeronet/http-request.hpp"
#include "aeronet/http-response-writer.hpp"
#include "aeronet/http-response.hpp"
#include "aeronet/http-server-config.hpp"
#include "aeronet/http-status-code.hpp"
#include "aeronet/log.hpp"
#include "aeronet/static-file-handler.hpp"
#include "aeronet/sys-test-support.hpp"
#include "aeronet/temp-file.hpp"
#include "aeronet/test_server_tls_fixture.hpp"
#include "aeronet/test_tls_client.hpp"
#include "aeronet/test_util.hpp"
#include "aeronet/tls-config.hpp"
#include "aeronet/tls-ticket-key-store.hpp"

#ifdef AERONET_ENABLE_HTTP2
#include "aeronet/test_server_http2_tls_fixture.hpp"
#include "aeronet/test_tls_http2_client.hpp"
#endif

namespace aeronet {
using namespace std::chrono_literals;

TEST(HttpTlsBasic, LargePayload) {
  std::string largeBody(1 << 24, 'a');
  // Prepare config with in-memory self-signed cert/key
  test::TlsTestServer ts({"http/1.1"}, [&](HttpServerConfig& cfg) {
    cfg.withMaxOutboundBufferBytes(largeBody.size() + 512);  // +512 for headers
    cfg.withKeepAliveTimeout(std::chrono::hours(1));
  });
  ts.setDefault([&largeBody]([[maybe_unused]] const HttpRequest& req) { return HttpResponse(largeBody); });
  test::TlsClient client(ts.port());
  auto raw = client.get("/hello", {http::Header{"X-Test", "tls"}});
  ASSERT_FALSE(raw.empty());
  EXPECT_TRUE(raw.contains("HTTP/1.1 200"));
  EXPECT_TRUE(raw.contains(largeBody));
}

TEST(HttpTlsCompressionStreaming, CompressionActivatedOverThresholdTls) {
  CompressionConfig compressionConfig;
  compressionConfig.minBytes = 32;
  if constexpr (zlibEnabled()) {
    compressionConfig.preferredFormats.push_back(Encoding::gzip);
  }
  if constexpr (zstdEnabled()) {
    compressionConfig.preferredFormats.push_back(Encoding::zstd);
  }
  if constexpr (brotliEnabled()) {
    compressionConfig.preferredFormats.push_back(Encoding::br);
  }
  // Apply compression configuration while preserving TLS cert/key generated by the
  // TlsTestServer helper (don't overwrite the whole HttpServerConfig instance).
  test::TlsTestServer ts({"http/1.1"}, [&](HttpServerConfig& cfg) { cfg.withCompression(compressionConfig); });

  std::string part1(20000, 'a');
  std::string part2(64000, 'b');

  ts.setDefault([&](const HttpRequest&, HttpResponseWriter& writer) {
    writer.status(http::StatusCodeOK);
    writer.contentType("text/plain");

    static constexpr std::size_t kChunkSize = 512;

    std::string_view buf1 = part1;
    std::string_view buf2 = part2;

    while (!buf1.empty()) {
      std::string_view chunk = buf1.substr(0, std::min(buf1.size(), kChunkSize));
      writer.writeBody(chunk);
      buf1.remove_prefix(chunk.size());
    }

    while (!buf2.empty()) {
      std::string_view chunk = buf2.substr(0, std::min(buf2.size(), kChunkSize));
      writer.writeBody(chunk);
      buf2.remove_prefix(chunk.size());
    }
    writer.end();
  });

  test::TlsClient client(ts.port());
  auto raw = client.get("/sgz", {http::Header{"Accept-Encoding", "gzip,zstd,br"}});

  EXPECT_GT(raw.size(), 0);

  // Extract Content-Encoding and de-chunked body using the test helper
  auto encBody = test::extractContentEncodingAndBody(raw);
  std::string enc = std::string(encBody.contentEncoding);
  std::string body = std::move(encBody.body);

  EXPECT_EQ(compressionConfig.preferredFormats.empty(), enc.empty());
  EXPECT_EQ(body, part1 + part2);
}

namespace {
// Large response GET using TlsClient (simplified replacement).
std::string tlsGetLarge(auto port) {
  test::TlsClient client(port);
  if (!client.handshakeOk()) {
    return {};
  }
  return client.get("/large");
}
}  // namespace

TEST(HttpTlsNegative, LargeResponseFragmentation) {
  test::TlsTestServer ts;  // basic TLS
  auto port = ts.port();
  ts.setDefault([](const HttpRequest&) { return HttpResponse(200).body(std::string(300000, 'A')); });
  std::string resp = tlsGetLarge(port);
  // helper freed temporary key/cert
  ASSERT_FALSE(resp.empty());
  ASSERT_TRUE(resp.contains("HTTP/1.1 200"));
  ASSERT_TRUE(resp.contains("AAAA"));
}

TEST(HttpOptionsTraceTls, TraceDisabledOnTlsPolicyRejectsTlsTrace) {
  using namespace test;
  // Use TlsTestServer and set TracePolicy to EnabledPlainOnly (reject TRACE over TLS)
  TlsTestServer ts(
      {}, [](HttpServerConfig& cfg) { cfg.withTracePolicy(HttpServerConfig::TraceMethodPolicy::EnabledPlainOnly); });

  // Default handler (not needed but keep server alive)
  ts.setDefault([](const HttpRequest&) { return HttpResponse(http::StatusCodeOK); });

  // Use a TLS client to send a TRACE request; it should be rejected (405)
  TlsClient client(ts.port());
  ASSERT_TRUE(client.handshakeOk());
  client.writeAll("TRACE /test HTTP/1.1\r\nHost: localhost\r\nConnection: close\r\n\r\n");
  auto raw = client.readAll();
  ASSERT_TRUE(raw.contains("405")) << raw;
}

TEST(HttpOptionsTraceTls, TraceEnabledOnTlsAllowsTlsTrace) {
  using namespace test;
  // EnabledPlainAndTLS should allow TRACE over TLS
  TlsTestServer ts(
      {}, [](HttpServerConfig& cfg) { cfg.withTracePolicy(HttpServerConfig::TraceMethodPolicy::EnabledPlainAndTLS); });
  ts.setDefault([](const HttpRequest&) { return HttpResponse(http::StatusCodeOK); });

  TlsClient client(ts.port());
  ASSERT_TRUE(client.handshakeOk());
  client.writeAll("TRACE /test HTTP/1.1\r\nHost: localhost\r\nConnection: close\r\n\r\n");
  auto raw = client.readAll();
  ASSERT_TRUE(raw.contains("200")) << raw;
}

TEST(HttpTlsStreaming, ChunkedSimpleTls) {
  test::TlsTestServer ts({"http/1.1"});
  ts.setDefault([]([[maybe_unused]] const HttpRequest& req, HttpResponseWriter& writer) {
    writer.status(200);
    writer.contentType("text/plain");
    writer.writeBody("hello ");
    writer.writeBody("tls");
    writer.end();
  });
  test::TlsClient client(ts.port());
  auto raw = client.get("/stream", {});
  ASSERT_FALSE(raw.empty());
  ASSERT_TRUE(raw.contains("HTTP/1.1 200"));
  ASSERT_TRUE(raw.contains("6\r\nhello "));  // chunk size 6
  ASSERT_TRUE(raw.contains("3\r\ntls"));     // chunk size 3
}

TEST(HttpTlsStreaming, SendFileFallbackBuffers) {
  constexpr std::string_view kPayload = "tls sendfile body contents";
  test::ScopedTempDir tmpDir;
  test::ScopedTempFile tmp(tmpDir, kPayload);
  std::string path = tmp.filePath().string();

  test::TlsTestServer ts({"http/1.1"});
  ts.setDefault([path](const HttpRequest&, HttpResponseWriter& writer) {
    writer.status(http::StatusCodeOK);
    writer.file(File(path));
    writer.end();
  });

  test::TlsClient client(ts.port());
  auto raw = client.get("/file", {});

  ASSERT_FALSE(raw.empty());
  ASSERT_TRUE(raw.starts_with("HTTP/1.1 200"));
  ASSERT_TRUE(raw.contains(MakeHttp1HeaderLine(http::ContentLength, std::to_string(kPayload.size()))));
  ASSERT_FALSE(raw.contains(http::TransferEncoding));

  auto headerEnd = raw.find(http::DoubleCRLF);
  ASSERT_NE(std::string::npos, headerEnd);
  std::string body = raw.substr(headerEnd + http::DoubleCRLF.size());
  EXPECT_EQ(body, kPayload);
}

TEST(HttpTlsStreamingBackpressure, LargeChunksTls) {
  test::TlsTestServer ts({"http/1.1"}, nullptr, std::chrono::milliseconds{20});
  // Create large chunks to exercise TLS partial writes
  static constexpr std::size_t kChunkSize = 65536;
  static constexpr int kNbChunks = 32;

  std::string chunk(kChunkSize, 'X');
  ts.setDefault([&]([[maybe_unused]] const HttpRequest& req, HttpResponseWriter& writer) {
    writer.status(200);
    writer.contentType("text/plain");
    // write several large chunks
    for (int chunkPos = 0; chunkPos < kNbChunks; ++chunkPos) {
      writer.writeBody(chunk);
    }
    writer.end();
  });

  test::TlsClient client(ts.port());
  auto raw = client.get("/large", {});
  ASSERT_FALSE(raw.empty());
  // Response should contain a sizable body; simple sanity: expect more than one chunk size marker or body length
  EXPECT_GT(raw.size(), kChunkSize * static_cast<std::size_t>(kNbChunks));
}

namespace {
struct EvpMacCtxDeleter {
  void operator()(EVP_MAC_CTX* ctx) const {
    if (ctx != nullptr) {
      ::EVP_MAC_CTX_free(ctx);
    }
  }
};
using EvpMacCtxPtr = std::unique_ptr<EVP_MAC_CTX, EvpMacCtxDeleter>;

EvpMacCtxPtr createMacContext() {
  EVP_MAC* mac = ::EVP_MAC_fetch(nullptr, "HMAC", nullptr);
  if (mac == nullptr) {
    return nullptr;
  }
  EVP_MAC_CTX* ctx = ::EVP_MAC_CTX_new(mac);
  ::EVP_MAC_free(mac);
  return EvpMacCtxPtr(ctx);
}
}  // namespace

TEST(HttpTlsSessionTickets, StaticKeyStoreEncryptsAndDecrypts) {
  TlsTicketKeyStore store(std::chrono::seconds(3600), 4);
  TLSConfig::SessionTicketKey material{};
  for (std::size_t i = 0; i < material.size(); ++i) {
    material[i] = static_cast<std::byte>(i);
  }
  store.loadStaticKeys(std::span<const TLSConfig::SessionTicketKey>{&material, 1});

  unsigned char name[16]{};
  unsigned char iv[EVP_MAX_IV_LENGTH]{};
  std::unique_ptr<EVP_CIPHER_CTX, decltype(&::EVP_CIPHER_CTX_free)> encCtx{::EVP_CIPHER_CTX_new(),
                                                                           &::EVP_CIPHER_CTX_free};
  EvpMacCtxPtr encMac = createMacContext();
  ASSERT_NE(encCtx.get(), nullptr);
  ASSERT_NE(encMac.get(), nullptr);
  ASSERT_EQ(store.processTicket(name, iv, EVP_MAX_IV_LENGTH, encCtx.get(), encMac.get(), 1), 1);

  std::unique_ptr<EVP_CIPHER_CTX, decltype(&::EVP_CIPHER_CTX_free)> decCtx{::EVP_CIPHER_CTX_new(),
                                                                           &::EVP_CIPHER_CTX_free};
  EvpMacCtxPtr decMac = createMacContext();
  ASSERT_NE(decCtx.get(), nullptr);
  ASSERT_NE(decMac.get(), nullptr);
  ASSERT_EQ(store.processTicket(name, iv, EVP_MAX_IV_LENGTH, decCtx.get(), decMac.get(), 0), 1);
}

TEST(HttpTlsSessionTickets, AutoRotationRefreshesPrimaryKeyAndRejectsUnknown) {
  TlsTicketKeyStore store(std::chrono::seconds(1), 2);

  auto issue = [&](unsigned char (&out)[16]) {
    unsigned char iv[EVP_MAX_IV_LENGTH]{};
    std::unique_ptr<EVP_CIPHER_CTX, decltype(&::EVP_CIPHER_CTX_free)> ctx{::EVP_CIPHER_CTX_new(),
                                                                          &::EVP_CIPHER_CTX_free};
    EvpMacCtxPtr mctx = createMacContext();
    ASSERT_NE(ctx.get(), nullptr);
    ASSERT_NE(mctx.get(), nullptr);
    ASSERT_EQ(store.processTicket(out, iv, EVP_MAX_IV_LENGTH, ctx.get(), mctx.get(), 1), 1);
  };

  unsigned char first[16]{};
  issue(first);
  std::this_thread::sleep_for(std::chrono::seconds(1));
  unsigned char second[16]{};
  issue(second);
  EXPECT_NE(std::memcmp(first, second, sizeof(first)), 0);

  unsigned char bogus[16]{};
  unsigned char iv[EVP_MAX_IV_LENGTH]{};
  std::unique_ptr<EVP_CIPHER_CTX, decltype(&::EVP_CIPHER_CTX_free)> ctx{::EVP_CIPHER_CTX_new(), &::EVP_CIPHER_CTX_free};
  EvpMacCtxPtr mctx = createMacContext();
  ASSERT_NE(ctx.get(), nullptr);
  ASSERT_NE(mctx.get(), nullptr);
  EXPECT_EQ(store.processTicket(bogus, iv, EVP_MAX_IV_LENGTH, ctx.get(), mctx.get(), 0), 0);
}

#ifdef AERONET_ENABLE_HTTP2
TEST(HttpRangeStatic_H2Tls, ServeCompleteFile_H2Tls) {
  using namespace aeronet::test;
  test::TlsHttp2TestServer ts;

  test::ScopedTempDir tmpDir;
  test::ScopedTempFile tmp(tmpDir, "abcdefghij");
  const std::string fileName = tmp.filename();

  ts.setDefault(StaticFileHandler(tmp.dirPath()));

  test::TlsHttp2Client client(ts.port());
  ASSERT_TRUE(client.isConnected());
  EXPECT_EQ(client.negotiatedAlpn(), "h2");

  auto resp = client.get(std::string("/" + fileName));
  EXPECT_EQ(resp.statusCode, static_cast<int>(http::StatusCodeOK));
  EXPECT_EQ(resp.body, "abcdefghij");

  auto findHeader = [&](const auto& headers, std::string_view key) -> std::string {
    for (const auto& [name, value] : headers) {
      if (CaseInsensitiveEqual(name, key)) {
        return value;
      }
    }
    return {};
  };

  EXPECT_EQ(findHeader(resp.headers, "accept-ranges"), "bytes");
  EXPECT_FALSE(findHeader(resp.headers, "etag").empty());
  EXPECT_FALSE(findHeader(resp.headers, "last-modified").empty());
}

TEST(HttpRangeStatic_H2Tls, SingleRangePartialContent_H2Tls) {
  using namespace aeronet::test;
  test::TlsHttp2TestServer ts;

  test::ScopedTempDir tmpDir;
  test::ScopedTempFile tmp(tmpDir, "abcdefghij");
  const std::string fileName = tmp.filename();

  ts.setDefault(StaticFileHandler(tmp.dirPath()));

  test::TlsHttp2Client client(ts.port());
  ASSERT_TRUE(client.isConnected());

  auto resp = client.request("GET", std::string("/" + fileName), {{"range", "bytes=0-3"}});
  EXPECT_EQ(resp.statusCode, static_cast<int>(http::StatusCodePartialContent));
  EXPECT_EQ(resp.body, "abcd");

  auto findHeader = [&](const auto& headers, std::string_view key) -> std::string {
    for (const auto& [name, value] : headers) {
      if (CaseInsensitiveEqual(name, key)) {
        return value;
      }
    }
    return {};
  };

  EXPECT_EQ(findHeader(resp.headers, "content-range"), "bytes 0-3/10");
}

TEST(HttpRangeStatic_H2Tls, UnsatisfiableRange_H2Tls) {
  using namespace aeronet::test;
  test::TlsHttp2TestServer ts;

  test::ScopedTempDir tmpDir;
  test::ScopedTempFile tmp(tmpDir, "abcdefghij");
  const std::string fileName = tmp.filename();

  ts.setDefault(StaticFileHandler(tmp.dirPath()));

  test::TlsHttp2Client client(ts.port());
  ASSERT_TRUE(client.isConnected());

  auto resp = client.request("GET", std::string("/" + fileName), {{"range", "bytes=100-200"}});
  EXPECT_EQ(resp.statusCode, static_cast<int>(http::StatusCodeRangeNotSatisfiable));

  auto findHeader = [&](const auto& headers, std::string_view key) -> std::string {
    for (const auto& [name, value] : headers) {
      if (CaseInsensitiveEqual(name, key)) {
        return value;
      }
    }
    return {};
  };

  EXPECT_EQ(findHeader(resp.headers, "content-range"), "bytes */10");
}

TEST(HttpRangeStatic_H2Tls, LargeFileStreaming_H2Tls) {
  using namespace aeronet::test;
  test::TlsHttp2TestServer ts;

  test::ScopedTempDir tmpDir;

  static constexpr std::size_t kSize = 200000;
  std::string payload;
  payload.resize(kSize);
  std::ranges::transform(std::views::iota(std::size_t{0}, kSize), payload.begin(),
                         [](std::size_t idx) { return static_cast<char>('a' + (idx % 26)); });

  test::ScopedTempFile tmp(tmpDir, payload);
  const std::string fileName = tmp.filename();

  ts.setDefault(StaticFileHandler(tmp.dirPath()));

  test::TlsHttp2Client client(ts.port());
  ASSERT_TRUE(client.isConnected());
  EXPECT_EQ(client.negotiatedAlpn(), "h2");

  auto resp = client.get(std::string("/" + fileName));
  EXPECT_EQ(resp.statusCode, static_cast<int>(http::StatusCodeOK));
  ASSERT_EQ(resp.body.size(), payload.size());
  EXPECT_EQ(resp.body.substr(0, 128), payload.substr(0, 128));
  EXPECT_EQ(resp.body.substr(resp.body.size() - 128), payload.substr(payload.size() - 128));
}
#endif

#if defined(BIO_CTRL_GET_KTLS_SEND) && !defined(OPENSSL_NO_KTLS)
TEST(HttpTlsKtlsMode, EnabledModeTracksStats) {
  log::set_level(log::level::debug);
  test::TlsTestServer ts({"http/1.1"},
                         [](HttpServerConfig& cfg) { cfg.withTlsKtlsMode(TLSConfig::KtlsMode::Enabled); });
  ts.setDefault([](const HttpRequest&) { return HttpResponse("ktls"); });

  test::TlsClient client(ts.port());
  ASSERT_TRUE(client.handshakeOk());
  auto raw = client.get("/ktls", {});
  ASSERT_FALSE(raw.empty());
  ASSERT_TRUE(raw.contains("HTTP/1.1 200"));

  const auto stats = ts.stats();
  ASSERT_GE(stats.totalRequestsServed, 1U);
  EXPECT_GE(stats.ktlsSendEnabledConnections + stats.ktlsSendEnableFallbacks, 1U);
  EXPECT_EQ(stats.ktlsSendForcedShutdowns, 0U);
}

// Integration-style coverage across kTLS modes using real TLS connections.
// Disabled: should not attempt kTLS (no counters incremented).
TEST(HttpTlsKtlsMode, DisabledModeDoesNotAttemptKtls) {
  test::TlsTestServer ts({}, [](HttpServerConfig& cfg) { cfg.withTlsKtlsMode(TLSConfig::KtlsMode::Disabled); });
  ts.setDefault([](const HttpRequest&) { return HttpResponse(http::StatusCodeOK); });

  test::TlsClient client(ts.port());
  ASSERT_TRUE(client.handshakeOk());
  auto raw = client.get("/disabled", {});
  ASSERT_FALSE(raw.empty());
  ASSERT_TRUE(raw.contains("HTTP/1.1 200"));

  const auto stats = ts.stats();
  EXPECT_EQ(stats.ktlsSendEnabledConnections, 0U);
  EXPECT_EQ(stats.ktlsSendEnableFallbacks, 0U);
  EXPECT_EQ(stats.ktlsSendForcedShutdowns, 0U);
}

// Opportunistic — expect either enabled or fallback, but never forced shutdowns.
TEST(HttpTlsKtlsMode, OpportunisticModeEnabledOrFallbackNoForcedClose) {
  test::TlsTestServer ts({}, [](HttpServerConfig& cfg) { cfg.withTlsKtlsMode(TLSConfig::KtlsMode::Opportunistic); });
  ts.setDefault([](const HttpRequest&) { return HttpResponse(http::StatusCodeOK); });

  test::TlsClient client(ts.port());
  ASSERT_TRUE(client.handshakeOk());
  // Force a kTLS enable failure path by making SSL_get_wbio return nullptr once.
  test::ForceNextSslGetWbioNull(1);
  auto raw = client.get("/auto", {});
  ASSERT_FALSE(raw.empty());
  ASSERT_TRUE(raw.contains("HTTP/1.1 200"));

  const auto stats = ts.stats();
  EXPECT_GE(stats.ktlsSendEnabledConnections + stats.ktlsSendEnableFallbacks, 1U);
  EXPECT_EQ(stats.ktlsSendForcedShutdowns, 0U);
}

// Enabled: similar to Opportunistic for warnings on fallback — ensure no forced shutdowns.
TEST(HttpTlsKtlsMode, EnabledModeEnabledOrFallbackNoForcedClose) {
  test::TlsTestServer ts({}, [](HttpServerConfig& cfg) { cfg.withTlsKtlsMode(TLSConfig::KtlsMode::Enabled); });
  ts.setDefault([](const HttpRequest&) { return HttpResponse(http::StatusCodeOK); });

  test::TlsClient client(ts.port());
  ASSERT_TRUE(client.handshakeOk());
  // Drive failure by forcing SSL_get_wbio(nullptr) to exercise Failed path.
  test::ForceNextSslGetWbioNull(1);
  auto raw = client.get("/enabled", {});
  ASSERT_FALSE(raw.empty());
  ASSERT_TRUE(raw.contains("HTTP/1.1 200"));

  const auto stats = ts.stats();
  EXPECT_GE(stats.ktlsSendEnabledConnections + stats.ktlsSendEnableFallbacks, 1U);
  EXPECT_EQ(stats.ktlsSendForcedShutdowns, 0U);
}

// Forced: treat failure as fatal — expect either enabled OR forced shutdown recorded.
TEST(HttpTlsKtlsMode, ForcedModeEnabledOrForcedShutdown) {
  test::TlsTestServer ts({}, [](HttpServerConfig& cfg) { cfg.withTlsKtlsMode(TLSConfig::KtlsMode::Required); });
  ts.setDefault([](const HttpRequest&) { return HttpResponse(http::StatusCodeOK); });

  test::TlsClient client(ts.port());
  ASSERT_TRUE(client.handshakeOk());
  // Force failure via SSL_get_wbio(nullptr) to ensure forced shutdown is recorded when kTLS cannot be enabled.
  test::ForceNextSslGetWbioNull(1);
  [[maybe_unused]] auto raw = client.get("/forced", {});

  const auto stats = ts.stats();
  EXPECT_GE(stats.ktlsSendEnabledConnections + stats.ktlsSendForcedShutdowns, 1U);
}

// Test file serving over TLS with kTLS explicitly disabled.
// This exercises the user-space TLS path (pread + SSL_write) via flushUserSpaceTlsBuffer.
TEST(HttpTlsKtlsMode, DisabledModeFileServing) {
  // Create a file large enough to require multiple chunk iterations
  static constexpr std::size_t kFileSize = 256UL * 1024;  // 256KB
  std::string largePayload(kFileSize, 'F');
  // Add some variety to detect corruption
  for (std::size_t pos = 0; pos < kFileSize; pos += 1024) {
    largePayload[pos] = static_cast<char>('A' + ((pos / 1024) % 26));
  }

  test::ScopedTempDir tmpDir;
  test::ScopedTempFile tmpFile(tmpDir, largePayload);
  std::string filePath = tmpFile.filePath().string();

  // Explicitly disable kTLS to force user-space TLS path
  test::TlsTestServer ts({"http/1.1"},
                         [](HttpServerConfig& cfg) { cfg.withTlsKtlsMode(TLSConfig::KtlsMode::Disabled); });

  ts.setDefault([filePath](const HttpRequest&, HttpResponseWriter& writer) {
    writer.status(http::StatusCodeOK);
    writer.file(File(filePath));
    writer.end();
  });

  test::TlsClient client(ts.port());
  ASSERT_TRUE(client.handshakeOk());
  auto raw = client.get("/largefile", {});

  ASSERT_FALSE(raw.empty());
  ASSERT_TRUE(raw.starts_with("HTTP/1.1 200"));

  auto headerEnd = raw.find(http::DoubleCRLF);
  ASSERT_NE(std::string::npos, headerEnd);
  std::string body = raw.substr(headerEnd + http::DoubleCRLF.size());

  // Verify the full file was received correctly
  EXPECT_EQ(body.size(), kFileSize);
  EXPECT_EQ(body, largePayload);

  // Verify kTLS was NOT used - when Disabled mode, enableKtlsSend() is not called
  // so neither ktlsSendEnabledConnections nor ktlsSendEnableFallbacks are incremented.
  const auto stats = ts.stats();
  EXPECT_EQ(stats.ktlsSendEnabledConnections, 0U);
  EXPECT_EQ(stats.ktlsSendEnableFallbacks, 0U);
  EXPECT_EQ(stats.ktlsSendForcedShutdowns, 0U);
  // But ktlsSendBytes should be 0 since kTLS was not used
  EXPECT_EQ(stats.ktlsSendBytes, 0U);
}

// When OpenSSL headers do not expose BIO_CTRL_SET_KTLS_SEND, TlsTransport::enableKtlsSend()
// reports Unsupported at compile time. Cover that switch branch opportunistically.
#ifndef BIO_CTRL_SET_KTLS_SEND
TEST(HttpTlsKtlsUnsupported, AutoOrEnabledFallBackWithoutForcedClose) {
  test::TlsTestServer ts({}, [](HttpServerConfig& cfg) { cfg.withTlsKtlsMode(TLSConfig::KtlsMode::Enabled); });
  ts.setDefault([](const HttpRequest&) { return HttpResponse(http::StatusCodeOK); });

  test::TlsClient client(ts.port());
  ASSERT_TRUE(client.handshakeOk());
  auto raw = client.get("/unsupported", {});
  ASSERT_FALSE(raw.empty());
  ASSERT_TRUE(raw.starts_with("HTTP/1.1 200"));
}
#endif
#if defined(__linux__)
// Integration test: request kTLS + zerocopy via server config and exercise large response path.
TEST(HttpTlsKtlsZerocopy, EnabledZerocopyWithKtls) {
  using namespace aeronet::test;
  // Ask the server to enable both kTLS send and MSG_ZEROCOPY (may fall back depending on kernel).
  TlsTestServer ts({}, [](HttpServerConfig& cfg) {
    cfg.withTlsKtlsMode(TLSConfig::KtlsMode::Enabled);
    cfg.withZerocopyMode(ZerocopyMode::Enabled);
  });

  // Response slightly above zerocopy threshold
  std::string body(aeronet::kZeroCopyMinPayloadSize + 1024, 'Z');
  ts.setDefault([&body](const HttpRequest&) { return HttpResponse(body); });

  test::TlsClient client(ts.port());
  ASSERT_TRUE(client.handshakeOk());
  auto raw = client.get("/zerocopy", {});
  ASSERT_FALSE(raw.empty());
  ASSERT_TRUE(raw.starts_with("HTTP/1.1 200"));

  const auto stats = ts.stats();
  // kTLS should have been attempted; either enabled or fallback is acceptable.
  EXPECT_GE(stats.ktlsSendEnabledConnections + stats.ktlsSendEnableFallbacks, 1U);
}
#endif
#endif
}  // namespace aeronet