#include <gtest/gtest.h>

#include <algorithm>
#include <cstddef>
#include <string>
#include <utility>

#include "aeronet/compression-config.hpp"
#include "aeronet/encoding.hpp"
#include "aeronet/http-request.hpp"
#include "aeronet/http-response-writer.hpp"
#include "aeronet/http-server-config.hpp"
#include "aeronet/test_server_tls_fixture.hpp"
#include "aeronet/test_tls_client.hpp"
#include "aeronet/test_util.hpp"

using namespace aeronet;

TEST(HttpTlsCompressionStreaming, CompressionActivatedOverThresholdTls) {
  CompressionConfig compressionConfig;
  compressionConfig.minBytes = 32;
#ifdef AERONET_ENABLE_ZLIB
  compressionConfig.preferredFormats.push_back(Encoding::gzip);
#endif
#ifdef AERONET_ENABLE_ZSTD
  compressionConfig.preferredFormats.push_back(Encoding::zstd);
#endif
#ifdef AERONET_ENABLE_BROTLI
  compressionConfig.preferredFormats.push_back(Encoding::br);
#endif
  // Apply compression configuration while preserving TLS cert/key generated by the
  // TlsTestServer helper (don't overwrite the whole HttpServerConfig instance).
  aeronet::test::TlsTestServer ts({"http/1.1"}, [&](HttpServerConfig& cfg) { cfg.withCompression(compressionConfig); });

  std::string part1(20000, 'a');
  std::string part2(64000, 'b');

  ts.setDefault([&](const HttpRequest&, HttpResponseWriter& writer) {
    writer.statusCode(200);
    writer.contentType("text/plain");

    static constexpr std::size_t kChunkSize = 512;

    std::string_view buf1 = part1;
    std::string_view buf2 = part2;

    while (!buf1.empty()) {
      std::string_view chunk = buf1.substr(0, std::min(buf1.size(), kChunkSize));
      writer.writeBody(chunk);
      buf1.remove_prefix(chunk.size());
    }

    while (!buf2.empty()) {
      std::string_view chunk = buf2.substr(0, std::min(buf2.size(), kChunkSize));
      writer.writeBody(chunk);
      buf2.remove_prefix(chunk.size());
    }
    writer.end();
  });

  aeronet::test::TlsClient client(ts.port());
  auto raw = client.get("/sgz", {{"Accept-Encoding", "gzip,zstd,br"}});
  ASSERT_FALSE(raw.empty());

  EXPECT_GT(raw.size(), 0);

  // Extract Content-Encoding and de-chunked body using the test helper
  auto encBody = aeronet::test::extractContentEncodingAndBody(raw);
  std::string enc = std::string(encBody.contentEncoding);
  std::string body = std::move(encBody.body);

  EXPECT_EQ(compressionConfig.preferredFormats.empty(), enc.empty());
  EXPECT_EQ(body, part1 + part2);
}
